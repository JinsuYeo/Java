# Appendix 01 신입 개발자 오리엔테이션

## 메인 프레임의 시대
### 메인 프레임이라는 거대한 컴퓨터에 자체 연산 기능이 없는, 모니터나 키보드 같은 사용자 입출력 기기로 구성된 여러대의 터미널을 연결해서 사용.
* 모든 연산이 메인 프레임에서 이루어지는 중앙 집중형 구조.
* 소프트웨어 유지보수 용이. 하드웨어 유지보수에 한계.
* 보안 용이.

## 클라이언트/서버의 시대
### 메인 프레임이 하던 일 중, 비즈니스 로직 부분과 화면 출력 부분을 PC가 담당. 서버 쪽은 데이터 처리를 담당(메인 프레임 대신 워크스테이션 급 소형 서버가 담당).
* 인터넷의 보급 -> CGI 프로그램 만들기 시작.
* 서버 구축 및 운영비 절감
  * 서버 기능의 일부를 PC가 담당 -> 낮은 능의 하드웨어로도 서버 작업 수행 가능해짐.
  * PC에 애플리케이션 설치 -> 기능 추가, 변경 시 기존의 프로그램 제거 후 다시 설치해야 하는 불편함.
  * 보안에 취약(클라이언트에서 DBMS 서버에 직접 접근하기 때문에 아이디와 암호 노출 될 위험 존재)
  
## 웹의 시대
### 인터넷의 발전, 애플리케이션 실행되는 플랫폼으로 역할 확장.
* 애플리케이션 서버의 도입.
  * 업무 변화 증가 -> 기능 변경될 때마다 재설치 힘듦. -> PC가 처리하던 일을 다시 서버로 이전.
  * 하나의 메인 서버 x, 소형 서버 여러 대로 역할 분산 배치. -> 데이터 처리는 C/S 환경과 동일하게 별도의 DBMS 서버에서 처리, 비즈니스 로직은 애플리케이션 서버에서 처리.
* 웹 기술의 활용 
  * PC와 서버 간의 연결을 단순화하기 위해 웹 기술 활용됨. -> PC 쪽에서는 웹 브라우저를 통해 서버와 연결, 서버 쪽에서는 웹 서버가 PC와의 연결 담당.
  * PC <-> 웹 브라우저 <-> 웹 서버 <-> 애플리케이션 서버 <-> 애플리케이션
  ** 이렇게 웹 서버와 연동하여 작업을 처리하는 애플리케이션 서버를 웹 애플리케이션 서버(WAS)라 부름.
     
* WAS에서 구동되는 애플리케이션을 '웹 애플리케이션'이라 부름. -> 자바에서는 이것을 '서블릿'이라 부름.
* 웹 애플리케이션은 클라이언트의 요청을 처리하고, 그 결과를 웹 브라우저가 이해할 수 있는 HTML로 만들어 보냄.

* 서버 측 서비스 개발을 위해 Servlet/JSP 등 사용.
* 생산성 높이기 위해 스프링과 같은 프레임워크가 도입.
* 시스템 구축 시 EJB 같은 무거운 기술 대신 POJO(Plain Old Java Object) 같은 작고 가벼운 방법으로 자바 컴포넌트를 만들고 관리하는 방법이 새로운 개발 경향으로 떠올랐으며, 프레임워크 기반으로 시스템 구축하는 것이 유행을 탐.
  * POJO기반 프레임워크로 대표적인 것이 바로 스프링 프레임워크임.
  
## N-스크린과 클라우드의 시대
### 다양한 종류의 스마트 디바이스 등장, SaaS, PaaS 등 소프트웨어나 하드웨어 구축 없이 임대하여 사용하는 방식이 인기.
* HTML5(HTML, CSS, JavaScript,DOM API(실행 중 웹 페이지 변경 가능), AJAX(서버에 비동기 요청 가능)) 기술이 개발 도구로 사용됨.   
   
   
# Appendix 04 개발환경 구축
## JDK 설치, 이클립스 설치, 톰캣 서버 설치, 깃허브에서 실습 소스 가져오기.
* 서블릿을 실행하려면 Java EE 규약에 따라 만든 '서블릿 컨테이너'가 필요. 톰캣 서버는 아파치 재단에서 오픈 소스로 무료 배포하는 서블릿 컨테이너임.

# 1장 웹 애플리케이션의 이해
## 데스크톱 애플리케이션
* 웹 앱보다 실행 속도 빠르나 다음의 이유로 기업용 애플리케이션의 아키텍처로 쓰기에 적합하지 않음.
  * 기능 추가, 변경 시 다시 배포해야 하므로 ***배포 번거로움***.
  * 데이터베이스에 직접 접근하기 때문에 아이디와 암호 노출 될 위험 존재 -> ***보안에 취약함***.
  
## 클라이언트/서버 애플리케이션
* 서버에서 연산하고 클라이언트에 결과를 보내주므로, 신규 연산자가 추가되더라도 서버 쪽만 변경해주면 됨. -> 기능 변경이나 추가에 보다 유연하게 대응 가능.
* 서버에서 데이터 베이스에 접근하므로 보안이 강화됨.
* 서버가 한번에 하나의 클라이언트 하고만 연결된다는 문제점.
  * 현재 연결된 클라이언트와 연결이 끊어질 때까지 다른 클라이언트는 기다려야함.
  * 멀티 프로세스나 멀티 스레드 같은 병행처리 방법 도입해 해결가능.

## 클라이언트/서버 아키텍처의 진화
### 전통적인 C/S 시스템
* 전통적인 C/S 시스템에서 서버는 데이터를 처리하는 역할만 담당. -> 사실상 DBMS를 가리킴.
* 클라이언트는 UI와 비즈니스 처리 담당.
* 프로그램 뱐걍 시 PC에 다시 설치해야 한다는 단점.
* 클라이언트가 DBMS에 바로 접속하기 때문에 보안 문제 발생 가능.
   
### 개선된 C/S 시스템
* 클라이언트의 업무 처리 부분을 서버로 이관하고, 클라이언트는 오직 사용자와의 상호작용 처리하는 UI만을 담당.  
* 업무 처리만을 전담하는 서버를 ***애플리케이션 서버***라고 부름.
  * 클라이언트의 요청을 받아 업무 로직에 따라 DBMS 서버를 사용하여 데이터 처리.
  * 클라이언트가 직접 DBMS에 접근하지 않기 때문에 보안 강화됨.
  * 서버에서 업무 처리하기 때문에 서버 쪽 기능 변경 클라이언트에 적용 가능.
    * 서버 쪽 변경만으로 배포 문제를 완벽하게 해결할 수는 없지만 잦은 배포 줄일 수 있음.
* 클라이언트 <-> 애플리케이션 서버 <-> 서버(ex)DBMS)
    
## 웹 애플리케이션 아키텍처의 특징
* 클라이언트와 통신을 웹 서버가 전담. -> 네트워크 및 멀티 스레드 프로그래밍으로부터 탈출.
  * 네트워크나 멀티 스레딩 관련 코드 필요 x -> 웹 서버와 애플리케이션 서버가 대신 처리함.
* 애플리케이션 서버는 애플리케이션 실행 및 관리에 집중.
* 웹 브라우저 <-> 웹 서버 <-> 애플리케이션 서버 <-> DBMS 서버
* 배치란 클라이언트가 서비스를 요청했을 때 서버가 애플리케이션을 실행할 수 있도록 설치하는 것.
* 웹 환경에서는 비즈니스 로직과 UI 로직을 모두 서버에 배치하기 때문에 기능이 추가되거나 변경되어도 서버쪽만 바꾸면 됨. -> 배치하는 즉시 사용자는 재설치 없이 추가된 기능이나 변경된 기능 이용 가능.
  * 이때 클라이언트는 UI 로직 다운로드 후 실행함. -> 네트워크 오버헤드 발생.







